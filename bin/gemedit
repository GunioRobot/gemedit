#!/usr/bin/env ruby
#
#  Created on 2008-2-27.
#  Copyright (c) 2008. All rights reserved.

begin
  require 'rubygems'
rescue LoadError
  # no rubygems to load, so we fail silently
end

require 'optparse'

def command_completion
  exit 0 unless /\gemedit\b/ =~ ENV["COMP_LINE"]

  after_match = $'
  gem_match = (after_match.empty? || after_match =~ /\s$/) ? nil : after_match.split.last
  gem_names = if gem_match
      Gem.source_index.inject([]) { |ary, (full_name, spec)| ary << full_name if /^#{Regexp.escape gem_match}/i =~ full_name; ary }
    else
      Gem.source_index.map { |full_name, spec| full_name }
  end

  puts gem_names
  exit 0
end

OPTIONS = {
  :verbose => false,
  :editor => ENV['VISUAL'] || ENV['EDITOR'] || 'vi'
}
parser = OptionParser.new do |opts|
  opts.banner = <<BANNER
Open the source of installed gems in your favorite editor

Usage: #{File.basename($0)} GEM_NAME...

Options are:
BANNER
  opts.separator ""
  opts.on("--complete",
          "Used for gem name completion on the command line") { command_completion }
  opts.on("-e", "--editor EDITOR", String,
          "The editor to open the gems with", "Default: #{OPTIONS[:editor]}") { |editor| OPTIONS[:editor] = editor }
  opts.on("-v", "--verbose",
          "Enable verbose logging", "Default: #{OPTIONS[:verbose]}") { |verbose| OPTIONS[:verbose] = true }
  opts.on("-h", "--help",
          "Show this help message.") { puts opts; exit }
  opts.parse!(ARGV)
end

def get_gem(gem_name)
  possible_gems = Gem.source_index.inject([]) { |ary, (name, spec)| ary << spec if /^#{Regexp.escape(gem_name)}/i =~ spec.full_name; ary }.sort_by { |gem| gem.version }.reverse
  if possible_gems.size < 1
    puts "No gems found for #{gem_name}... skipping"
  end
  gem = possible_gems.first if possible_gems.map { |g| g.name }.uniq.size == 1
  gem ||= begin
    require 'rubygems/user_interaction'
    include Gem::DefaultUserInteraction
    list = possible_gems.map { |g| "#{g.name} #{g.version}" }
    list << 'None of the above'
    name, index = ui.choose_from_list("Choose which gem to view for '#{gem_name}':", list)
    possible_gems[index] if (0...possible_gems.size).include?(index)
  end
  gem
end

gems = ARGV.reject { |arg| arg.empty? }.map { |gem_name| get_gem(gem_name) }.compact

if gems.size > 0
  puts "Opening the following gems with #{OPTIONS[:editor]}:" if OPTIONS[:verbose]
  paths = gems.map do |gem|
    puts "  #{gem.full_name}: #{gem.full_gem_path}" if OPTIONS[:verbose]
    %Q{"#{gem.full_gem_path}"}
  end
  cmd = "#{OPTIONS[:editor]} #{paths.join(' ')}"
  puts "Running `#{cmd}`" if OPTIONS[:verbose]
  exec cmd
else
  puts "No gems found for editing"
end
exit 0
